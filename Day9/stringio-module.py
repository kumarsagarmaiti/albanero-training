# In some instances, data needs to be read or created in memory rather than in actual files seen by the Operating System. This is where the Python StringIO module comes into play.

# A file object acts just like a regular file. It allows most of the standard File I/O operations. However, there is one important difference between them. Regular files are created and stored as a softcopy visible to the operating system. However, file objects are created in memory, which automatically means they can be handled quicker and more efficiently.

# Here’s a scenario, say you have a logger that writes information onto a file, and you want to send the log output over the network. You can read the file and write its contents into the network, or you can write the log to a StringIO object and send it to the receiving network without using the file system at all.

import csv
from io import StringIO,BytesIO

example_sentence = "Hello World"
file_object = StringIO(example_sentence)

print(file_object.read())

file_object.write(" from Sagar")
# .seek()->This function is inherited from the abstract base class IOBase. You can pass an integer value, which will be the index from which it starts reading the stream.
file_object.seek(0)
print(file_object.read())

# .getvalue()->Gets all the content of the file object.
print(file_object.getvalue())

# .truncate()->will remove the characters after the index specified
file_object.truncate(11)
print(file_object.getvalue())

# .tell() – Also, being a part of the IOBase class, this function provides the current index position in the file object that Python is pointing to.

# .close() – This function is inherited in this module from IOBase. Running this will prevent any operations to the stream. Hence, it closes the file object. Any further attempts to operate will result in a ValueError . Re-running this function multiple times will not have any effect on the stream.

# file_object.close()
# print(file_object.getvalue())

# # Returns whether the file is interactive
# print("Is the file object interactive?", exampleObject.isatty())

# # Returns whether the file supports writing
# print("Is the file object writable?", exampleObject.writable())

# # Returns whether the file is readable
# print("Is the file object readable?", exampleObject.readable())

# # Returns whether the file is seekable
# print("Is the file object seekable?", exampleObject.seekable())

# # Returns whether the file object is closed or not
# print("Is the file object closed?", exampleObject.closed)

# Way to write a csv file. 
# exampleObject = StringIO()  # creating object
# writeCSV = csv.writer(exampleObject)

# # Writing the rows
# writeCSV.writerows([["pythonpool", "stringIO", "python"],
#                     ["12", "23", "4"],
#                     ["#", "%^", "^&"]])

# # Setting the cursor to the beginning of the csv file object
# exampleObject.seek(0)

# # Creating an iteration to print the rows of the csv file
# for eachRow in exampleObject:
#     print(eachRow)
# Why this is helpful?
# Let’s say we have to extract data online about the weather/climatic conditions of the USA and store relevant information onto a database. The standard procedure would be to download the data, unpack it, and add it to a CSV database. Therefore, with the help of modules like StringIO and CSV, we can automate such tasks, which would take up unnecessary time.
# Real world applications of StringIO include a web application stack where various parts of the stack may add text to the response, or testing the output generated by parts of a program which typically write to a file.
# StringIO and BytesIO are most useful when we need to mimic a normal file. 

new_file=BytesIO()
new_file.write(b'Hello world for the bytesio file')
new_file.seek(0)
print(new_file.getvalue())
new_file.close()